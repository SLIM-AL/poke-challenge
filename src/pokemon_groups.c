#include "pokemon_groups.h"

#include "data.h"
#include "global.h"
#include "global.fieldmap.h"
#include "random.h"
#include "region_map.h"
#include "constants/global.h"
#include "constants/map_groups.h"
#include "main_menu.h"

// Groups are autogenerated by the generate_groups.py script.
#include "autogenerated_pokemon_groups.h"

// https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
u32 HashInt(u32 x) {
  x = ((x >> 16) ^ x) * 0x119de1f3u;
  x = ((x >> 16) ^ x) * 0x119de1f3u;
  x = (x >> 16) ^ x;
  return x;
}

// https://stackoverflow.com/questions/2351087/what-is-the-best-32bit-hash-function-for-short-strings-tag-names
u32 HashStr(const u8 *str)
{
  s8 i;
  u32 h = str[0];
  for (i = 1; i < PLAYER_NAME_LENGTH + 1; ++i) {
    h = 37 * h + str[i];
  }
  return h;
}

// https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x.
// See also https://github.com/HowardHinnant/hash_append/issues/7
u32 HashCombine(u32 h1, u32 h2)
{
  return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));
}

u16 Index(const u16 *group, u32 hash) {
  // group[0] has the group size.
  return (hash % group[0]) + 1;
}

u16 IndexInto(const u16 *group, u32 hash) {
  // group[0] has the group size.
  return group[Index(group, hash)];
}

u32 GameHash() {
  static u32 gGameHash;
  if (gGameHash == 0) {
    gGameHash = HashStr(gSaveBlock1Ptr->rivalName);
  }
  const int version = 3;
  return (gGameHash << version) | (gGameHash >> (32 - version));
}

bool8 IsStarterGroup(const u16 * group) {
  if ((group == gGroup_GrassStarter1) ||
      (group == gGroup_GrassStarter3) ||
      (group == gGroup_FireStarter1) ||
      (group == gGroup_FireStarter3) ||
      (group == gGroup_WaterStarter1) ||
      (group == gGroup_WaterStarter3)) {
	  return TRUE;
  }
  return FALSE;
}

u32 HashMap(u16 map) {
  const u32 mapGroup = (map & 0xff00) >> 8;
  const u32 mapNum = map & 0x00ff;

  // Distribute 3-digit values evenly over all unsigned ints.
  // Some values will be 4 digits, but include/constants/map_groups.h
  // shows that we don't care about any maps with a mapNum over 100.
  return HashInt((mapNum * 10 + mapGroup) * 42949673);
}

u32 MapHashFromMapId(bool8 fine, u8 mapGroup, u8 mapNum) {
  static u32 gFineMapHash;
  static u32 gCoarseMapHash;
  static s8 gLastMap;

  const u16 map = (mapGroup << 8) | mapNum;
  u16 coarseMap = map;

  if (map != gLastMap) {
    if (mapGroup == 1 /*Dungeons*/) {
      // Mt. Moon.
      if (map == MAP_MT_MOON_B1F || map == MAP_MT_MOON_B2F) {
        coarseMap = MAP_MT_MOON_1F;
      }

      // Rock Tunnel.
      else if (map == MAP_ROCK_TUNNEL_B1F) {
        coarseMap = MAP_ROCK_TUNNEL_1F;
      }

      // Diglett's Cave.
      else if (map == MAP_DIGLETTS_CAVE_NORTH_ENTRANCE || map == MAP_DIGLETTS_CAVE_SOUTH_ENTRANCE) {
        coarseMap = MAP_DIGLETTS_CAVE_B1F;
      }

      // Pokemon Tower.
      else if (map == MAP_POKEMON_TOWER_4F || map == MAP_POKEMON_TOWER_5F) {
        coarseMap = MAP_POKEMON_TOWER_3F;
      }
      else if (map == MAP_POKEMON_TOWER_7F) {
        coarseMap = MAP_POKEMON_TOWER_6F;
      }

      // Pokemon Mansion.
      else if (map == MAP_POKEMON_MANSION_B1F) {
        coarseMap = MAP_POKEMON_MANSION_1F;
      }
      else if (map == MAP_POKEMON_MANSION_3F) {
        coarseMap = MAP_POKEMON_MANSION_2F;
      }

      // Seafoam Islands.
      else if (map == MAP_SEAFOAM_ISLANDS_B1F || map == MAP_SEAFOAM_ISLANDS_B2F) {
        coarseMap = MAP_SEAFOAM_ISLANDS_1F;
      }
      else if (map == MAP_SEAFOAM_ISLANDS_B4F) {
        coarseMap = MAP_SEAFOAM_ISLANDS_B3F;
      }

      // Victory Road.
      else if (map == MAP_VICTORY_ROAD_2F || map == MAP_VICTORY_ROAD_3F) {
        coarseMap = MAP_VICTORY_ROAD_1F;
      }

      // Mt. Ember.
      else if (map == MAP_MT_EMBER_SUMMIT_PATH_2F || map == MAP_MT_EMBER_SUMMIT_PATH_3F) {
        coarseMap = MAP_MT_EMBER_SUMMIT_PATH_1F;
      }
    }
    else if (mapGroup == 3 /*TownsAndRoutes*/) {
      // Pallet-Cinnabar.
      if (map == MAP_PALLET_TOWN || map == MAP_ROUTE21_NORTH || map == MAP_ROUTE21_SOUTH || map == MAP_CINNABAR_ISLAND) {
        coarseMap = MAP_ROUTE21_NORTH;
      }

      // Route19-Route20.
      else if (map == MAP_ROUTE19 || map == MAP_ROUTE20) {
        coarseMap = MAP_ROUTE19;
      }

      // Route12-Route13.
      else if (map == MAP_ROUTE12 || map == MAP_ROUTE13) {
        coarseMap = MAP_ROUTE12;
      }

      // Vermilion-Route11.
      else if (map == MAP_VERMILION_CITY || map == MAP_ROUTE11) {
        coarseMap = MAP_ROUTE11;
      }

      // Ruby path is post game so is excluded.
    }

    gFineMapHash = HashMap(map);
    gCoarseMapHash = HashMap(coarseMap);
    gLastMap =  map;
  }

  return fine ? gFineMapHash : gCoarseMapHash;
}

u32 MapHashFromPlayerSpot(bool8 fine) {
  struct WarpData* location = &gSaveBlock1Ptr->location;
  return MapHashFromMapId(fine, location->mapGroup, location->mapNum);
}

u32 MapHash() {
  return MapHashFromPlayerSpot(TRUE);
}

u32 CoarseMapHash() {
  return MapHashFromPlayerSpot(FALSE);
}

u16 GetSpeciesFromGroup(u16 species, u16 randInput) {
  const u16 *group;
  u8 random;
  u32 combinedHash;
  u32 tempCombinedHash1;
  u32 tempCombinedHash2;
  u32 mapHash;
  bool8 isMiddleEvoStarter = FALSE;

  if (species >= sizeof(gMonGroups) || gMonGroups[species] == NULL) {
    return species;
  }

  if (species == SPECIES_IVYSAUR || species == SPECIES_CHARMELEON || species == SPECIES_WARTORTLE ||
      species == SPECIES_BAYLEEF || species == SPECIES_QUILAVA || species == SPECIES_CROCONAW ||
      species == SPECIES_GROVYLE || species == SPECIES_COMBUSKEN || species == SPECIES_MARSHTOMP) {
    group = gMonGroups[species-1];
    isMiddleEvoStarter = TRUE;
  } else {
    group = gMonGroups[species];
  }


  // If this is a starter, just use the game hash.
  if (IsStarterGroup(group)) {
    // Int divide by 3 to preserve evolution chain.
    //
    // Don't take route into account, so that rival
    // has the same starter throughout the game.
    combinedHash = HashCombine(GameHash(), HashStr(gSpeciesNames[(species + 2) / 3]));
    return IndexInto(group, combinedHash) + isMiddleEvoStarter;
  }

  if (randInput != RAND_INPUT_PICK_1 && randInput != RAND_INPUT_PICK_2) {
    // Manual random value was provided.
    // For the 2025 challenge this works completely differently than before.
    random = randInput % 200;
    mapHash = MapHash() + randInput;
    if (random < 8) random += 8;
  } else {
    random = Random() % 200;
    mapHash = CoarseMapHash();
  }

  tempCombinedHash1 = HashCombine(GameHash(), mapHash * species);
  tempCombinedHash2 = HashCombine(mapHash, GameHash() * species);

  if (IndexInto(group, tempCombinedHash1) == IndexInto(group, tempCombinedHash2)) {
    ++tempCombinedHash2;
  }

  if (random < (8 - BadgeCount()) && group != gGroup_WaterIce1 && group != gGroup_WaterIce2) {
    // 0-4% chance that the player found the "rare" species
    // that is unique to the current (non-water) route. We
    // overwrite `group` and ignore `species`.
    group = gGroup_EarlyBoost;
    combinedHash = ~HashCombine(GameHash(), mapHash);
  } else if (random <= 134) {
    // 63-67% chance the player found the more common mapping to `species`.
    if (randInput == RAND_INPUT_PICK_1 || Index(group, tempCombinedHash1) < Index(group, tempCombinedHash2)) {
      combinedHash = tempCombinedHash1;
    } else {
      combinedHash = tempCombinedHash2;
    }
  } else {
    // 33% chance the player found the less common mapping to `species`.
    if (randInput == RAND_INPUT_PICK_1 || Index(group, tempCombinedHash1) >= Index(group, tempCombinedHash2)) {
      combinedHash = tempCombinedHash1;
    } else {
      combinedHash = tempCombinedHash2;
    }
  }

  return IndexInto(group, combinedHash);
}

