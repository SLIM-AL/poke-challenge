#include "pokemon_groups.h"

#include "data.h"
#include "global.h"
#include "global.fieldmap.h"
#include "random.h"
#include "region_map.h"

// Groups are autogenerated by the generate_groups.py script.
#include "autogenerated_pokemon_groups.h"

// https://stackoverflow.com/questions/2351087/what-is-the-best-32bit-hash-function-for-short-strings-tag-names
u32 Hash(const u8 *str)
{
  s8 i;
  u32 h = str[0];
  for (i = 1; str[i] + str[i-1]; ++i) {
    h = 37 * h + str[i];
  }
  return h;
}

// https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x.
// See also https://github.com/HowardHinnant/hash_append/issues/7
u32 HashCombine(u32 h1, u32 h2)
{
  return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));
}

u16 IndexInto(const u16 *group, u32 hash) {
  // group[0] has the group size.
  return group[(hash % group[0]) + 1];
}

u32 GameHash() {
  static u32 gGameHash;
  if (gGameHash == 0) {
    gGameHash = Hash(gSaveBlock1Ptr->rivalName);
  }
  return gGameHash;
}

u32 MapHash() {
  static u32 gMapHash;
  static u8 gLastRegionMapSectionId;
  if (gLastRegionMapSectionId != gMapHeader.regionMapSectionId) {
    u8 mapName[32];
    memset(mapName, 0, 32);
    GetMapNameGeneric(mapName, gMapHeader.regionMapSectionId);
    gMapHash = Hash(mapName);
    gLastRegionMapSectionId = gMapHeader.regionMapSectionId;
  }
  return gMapHash;
}

u16 GetSpeciesFromGroup(u16 species, u16 manual_random) {
  const u16 *group;
  s8 random;
  u32 combinedHash;

  if (species >= sizeof(gMonGroups) || gMonGroups[species] == NULL) {
    return species;
  }

  group = gMonGroups[species];

  // If this is a starter, just use the game hash.
  if ((group == gGroup_GrassStarter1) ||
      (group == gGroup_GrassStarter2) ||
      (group == gGroup_GrassStarter3) ||
      (group == gGroup_FireStarter1) ||
      (group == gGroup_FireStarter2) ||
      (group == gGroup_FireStarter3) ||
      (group == gGroup_WaterStarter1) ||
      (group == gGroup_WaterStarter2) ||
      (group == gGroup_WaterStarter3)) {
    // Int divide by 3 to preserve evolution chain.
    //
    // Don't take route into account, so that rival
    // has the same starter throughout the game.
    combinedHash = HashCombine(GameHash(), Hash(gSpeciesNames[(species + 2) / 3]));
    return IndexInto(group, combinedHash);
  }

  random = (manual_random ? manual_random : Random()) % 50;

  if ((random == 0) &&
      (group != gGroup_Fish1) && (group != gGroup_Fish2) &&
      (group != gGroup_LeggedWater1) && (group != gGroup_LeggedWater2)) {
    // 2% chance that the player found the "rare" species
    // that is unique to the current (non-water) route. We
    // overwrite `group` and ignore `species`.
    group = gGroup_Rare2Percent;
    combinedHash = HashCombine(GameHash(), MapHash());
  } else if (random <= 17) {
    // 34% chance the player found the less-common mapping
    // to `species`.
    combinedHash = HashCombine(GameHash(), MapHash() + (31 * species));
  } else {
    // 64% chance the player found the more-common mapping
    // to `species`. (Or 66% if in water.)
    combinedHash = HashCombine(MapHash(), GameHash() - (31 * species));
  }

  return IndexInto(group, combinedHash);
}

